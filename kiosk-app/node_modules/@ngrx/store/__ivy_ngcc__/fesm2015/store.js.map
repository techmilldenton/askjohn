{"version":3,"sources":["C:/Users/jonma/Desktop/denton-kiosk/node_modules/@ngrx/store/fesm2015/store.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwFA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAgGC,yGAGC;;;;;gDAEuC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA0WxC,yGAGC;;;;;;;;;;;;;;;;;;;kCAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA0CD;;;;0BAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;+EAoDD;kBACiB,AAGhB;;;;;;;;;;;;;kCAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA+GD,8EAGC;;;;;;;;;6HAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA8tBD,mTAGC;;;;;;;;;;;;;;;;;kCAQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAiCD,wRAGC;;;;;;;;;;;;;;;;;uFAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA2JD;;;;0BAGC","file":"store.js","sourcesContent":["/**\n * @license NgRx 9.0.0\n * (c) 2015-2018 Brandon Roberts, Mike Ryan, Rob Wormald, Victor Savkin\n * License: MIT\n */\nimport { Injectable, InjectionToken, Inject, isDevMode, NgZone, NgModule, Optional, SkipSelf, Injector } from '@angular/core';\nimport { BehaviorSubject, Observable, Subject, queueScheduler } from 'rxjs';\nimport { observeOn, withLatestFrom, scan, pluck, map, distinctUntilChanged } from 'rxjs/operators';\n\n/**\n * @fileoverview added by tsickle\n * Generated from: modules/store/src/action_creator.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * \\@description\n * Creates a configured `Creator` function that, when called, returns an object in the shape of the `Action` interface.\n *\n * Action creators reduce the explicitness of class-based action creators.\n *\n * \\@usageNotes\n *\n * **Declaring an action creator**\n *\n * Without additional metadata:\n * ```ts\n * export const increment = createAction('[Counter] Increment');\n * ```\n * With additional metadata:\n * ```ts\n * export const loginSuccess = createAction(\n *   '[Auth/API] Login Success',\n *   props<{ user: User }>()\n * );\n * ```\n * With a function:\n * ```ts\n * export const loginSuccess = createAction(\n *   '[Auth/API] Login Success',\n *   (response: Response) => response.user\n * );\n * ```\n *\n * **Dispatching an action**\n *\n * Without additional metadata:\n * ```ts\n * store.dispatch(increment());\n * ```\n * With additional metadata:\n * ```ts\n * store.dispatch(loginSuccess({ user: newUser }));\n * ```\n *\n * **Referencing an action in a reducer**\n *\n * Using a switch statement:\n * ```ts\n * switch (action.type) {\n *   // ...\n *   case AuthApiActions.loginSuccess.type: {\n *     return {\n *       ...state,\n *       user: action.user\n *     };\n *   }\n * }\n * ```\n * Using a reducer creator:\n * ```ts\n * on(AuthApiActions.loginSuccess, (state, { user }) => ({ ...state, user }))\n * ```\n *\n *  **Referencing an action in an effect**\n * ```ts\n * effectName$ = createEffect(\n *   () => this.actions$.pipe(\n *     ofType(AuthApiActions.loginSuccess),\n *     // ...\n *   )\n * );\n * ```\n * @template T, C\n * @param {?} type Describes the action that will be dispatched\n * @param {?=} config Additional metadata needed for the handling of the action.  See {\\@link createAction#usage-notes Usage Notes}.\n *\n * @return {?}\n */\nfunction createAction(type, config) {\n    if (typeof config === 'function') {\n        return defineType(type, (/**\n         * @param {...?} args\n         * @return {?}\n         */\n        (...args) => (Object.assign(Object.assign({}, config(...args)), { type }))));\n    }\n    /** @type {?} */\n    const as = config ? config._as : 'empty';\n    switch (as) {\n        case 'empty':\n            return defineType(type, (/**\n             * @return {?}\n             */\n            () => ({ type })));\n        case 'props':\n            return defineType(type, (/**\n             * @param {?} props\n             * @return {?}\n             */\n            (props) => (Object.assign(Object.assign({}, props), { type }))));\n        default:\n            throw new Error('Unexpected config.');\n    }\n}\n/**\n * @template P\n * @return {?}\n */\nfunction props() {\n    return { _as: 'props', _p: (/** @type {?} */ (undefined)) };\n}\n/**\n * @template C\n * @param {?} creators\n * @return {?}\n */\nfunction union(creators) {\n    return (/** @type {?} */ (undefined));\n}\n/**\n * @template T\n * @param {?} type\n * @param {?} creator\n * @return {?}\n */\nfunction defineType(type, creator) {\n    return Object.defineProperty(creator, 'type', {\n        value: type,\n        writable: false,\n    });\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: modules/store/src/actions_subject.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst INIT = (/** @type {?} */ ('@ngrx/store/init'));\nclass ActionsSubject extends BehaviorSubject {\n    constructor() {\n        super({ type: INIT });\n    }\n    /**\n     * @param {?} action\n     * @return {?}\n     */\n    next(action) {\n        if (typeof action === 'function') {\n            throw new TypeError(`\n        Dispatch expected an object, instead it received a function.\n        If you're using the createAction function, make sure to invoke the function\n        before dispatching the action. For example, someAction should be someAction().`);\n        }\n        else if (typeof action === 'undefined') {\n            throw new TypeError(`Actions must be objects`);\n        }\n        else if (typeof action.type === 'undefined') {\n            throw new TypeError(`Actions must have a type property`);\n        }\n        super.next(action);\n    }\n    /**\n     * @return {?}\n     */\n    complete() {\n        /* noop */\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        super.complete();\n    }\n}\nActionsSubject.decorators = [\n    { type: Injectable }\n];\n/** @nocollapse */\nActionsSubject.ctorParameters = () => [];\n/** @type {?} */\nconst ACTIONS_SUBJECT_PROVIDERS = [ActionsSubject];\n\n/**\n * @fileoverview added by tsickle\n * Generated from: modules/store/src/tokens.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst _ROOT_STORE_GUARD = new InjectionToken('@ngrx/store Internal Root Guard');\n/** @type {?} */\nconst _INITIAL_STATE = new InjectionToken('@ngrx/store Internal Initial State');\n/** @type {?} */\nconst INITIAL_STATE = new InjectionToken('@ngrx/store Initial State');\n/** @type {?} */\nconst REDUCER_FACTORY = new InjectionToken('@ngrx/store Reducer Factory');\n/** @type {?} */\nconst _REDUCER_FACTORY = new InjectionToken('@ngrx/store Internal Reducer Factory Provider');\n/** @type {?} */\nconst INITIAL_REDUCERS = new InjectionToken('@ngrx/store Initial Reducers');\n/** @type {?} */\nconst _INITIAL_REDUCERS = new InjectionToken('@ngrx/store Internal Initial Reducers');\n/** @type {?} */\nconst STORE_FEATURES = new InjectionToken('@ngrx/store Store Features');\n/** @type {?} */\nconst _STORE_REDUCERS = new InjectionToken('@ngrx/store Internal Store Reducers');\n/** @type {?} */\nconst _FEATURE_REDUCERS = new InjectionToken('@ngrx/store Internal Feature Reducers');\n/** @type {?} */\nconst _FEATURE_CONFIGS = new InjectionToken('@ngrx/store Internal Feature Configs');\n/** @type {?} */\nconst _STORE_FEATURES = new InjectionToken('@ngrx/store Internal Store Features');\n/** @type {?} */\nconst _FEATURE_REDUCERS_TOKEN = new InjectionToken('@ngrx/store Internal Feature Reducers Token');\n/** @type {?} */\nconst FEATURE_REDUCERS = new InjectionToken('@ngrx/store Feature Reducers');\n/**\n * User-defined meta reducers from StoreModule.forRoot()\n * @type {?}\n */\nconst USER_PROVIDED_META_REDUCERS = new InjectionToken('@ngrx/store User Provided Meta Reducers');\n/**\n * Meta reducers defined either internally by \\@ngrx/store or by library authors\n * @type {?}\n */\nconst META_REDUCERS = new InjectionToken('@ngrx/store Meta Reducers');\n/**\n * Concats the user provided meta reducers and the meta reducers provided on the multi\n * injection token\n * @type {?}\n */\nconst _RESOLVED_META_REDUCERS = new InjectionToken('@ngrx/store Internal Resolved Meta Reducers');\n/**\n * Runtime checks defined by the user via an InjectionToken\n * Defaults to `_USER_RUNTIME_CHECKS`\n * @type {?}\n */\nconst USER_RUNTIME_CHECKS = new InjectionToken('@ngrx/store User Runtime Checks Config');\n/**\n * Runtime checks defined by the user via forRoot()\n * @type {?}\n */\nconst _USER_RUNTIME_CHECKS = new InjectionToken('@ngrx/store Internal User Runtime Checks Config');\n/**\n * Runtime checks currently in use\n * @type {?}\n */\nconst _ACTIVE_RUNTIME_CHECKS = new InjectionToken('@ngrx/store Internal Runtime Checks');\n\n/**\n * @fileoverview added by tsickle\n * Generated from: modules/store/src/utils.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} reducers\n * @param {?=} initialState\n * @return {?}\n */\nfunction combineReducers(reducers, initialState = {}) {\n    /** @type {?} */\n    const reducerKeys = Object.keys(reducers);\n    /** @type {?} */\n    const finalReducers = {};\n    for (let i = 0; i < reducerKeys.length; i++) {\n        /** @type {?} */\n        const key = reducerKeys[i];\n        if (typeof reducers[key] === 'function') {\n            finalReducers[key] = reducers[key];\n        }\n    }\n    /** @type {?} */\n    const finalReducerKeys = Object.keys(finalReducers);\n    return (/**\n     * @param {?} state\n     * @param {?} action\n     * @return {?}\n     */\n    function combination(state, action) {\n        state = state === undefined ? initialState : state;\n        /** @type {?} */\n        let hasChanged = false;\n        /** @type {?} */\n        const nextState = {};\n        for (let i = 0; i < finalReducerKeys.length; i++) {\n            /** @type {?} */\n            const key = finalReducerKeys[i];\n            /** @type {?} */\n            const reducer = finalReducers[key];\n            /** @type {?} */\n            const previousStateForKey = state[key];\n            /** @type {?} */\n            const nextStateForKey = reducer(previousStateForKey, action);\n            nextState[key] = nextStateForKey;\n            hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n        }\n        return hasChanged ? nextState : state;\n    });\n}\n/**\n * @template T\n * @param {?} object\n * @param {?} keyToRemove\n * @return {?}\n */\nfunction omit(object, keyToRemove) {\n    return Object.keys(object)\n        .filter((/**\n     * @param {?} key\n     * @return {?}\n     */\n    key => key !== keyToRemove))\n        .reduce((/**\n     * @param {?} result\n     * @param {?} key\n     * @return {?}\n     */\n    (result, key) => Object.assign(result, { [key]: object[key] })), {});\n}\n/**\n * @param {...?} functions\n * @return {?}\n */\nfunction compose(...functions) {\n    return (/**\n     * @param {?} arg\n     * @return {?}\n     */\n    function (arg) {\n        if (functions.length === 0) {\n            return arg;\n        }\n        /** @type {?} */\n        const last = functions[functions.length - 1];\n        /** @type {?} */\n        const rest = functions.slice(0, -1);\n        return rest.reduceRight((/**\n         * @param {?} composed\n         * @param {?} fn\n         * @return {?}\n         */\n        (composed, fn) => fn(composed)), last(arg));\n    });\n}\n/**\n * @template T, V\n * @param {?} reducerFactory\n * @param {?=} metaReducers\n * @return {?}\n */\nfunction createReducerFactory(reducerFactory, metaReducers) {\n    if (Array.isArray(metaReducers) && metaReducers.length > 0) {\n        ((/** @type {?} */ (reducerFactory))) = compose.apply(null, [\n            ...metaReducers,\n            reducerFactory,\n        ]);\n    }\n    return (/**\n     * @param {?} reducers\n     * @param {?=} initialState\n     * @return {?}\n     */\n    (reducers, initialState) => {\n        /** @type {?} */\n        const reducer = reducerFactory(reducers);\n        return (/**\n         * @param {?} state\n         * @param {?} action\n         * @return {?}\n         */\n        (state, action) => {\n            state = state === undefined ? ((/** @type {?} */ (initialState))) : state;\n            return reducer(state, action);\n        });\n    });\n}\n/**\n * @template T, V\n * @param {?=} metaReducers\n * @return {?}\n */\nfunction createFeatureReducerFactory(metaReducers) {\n    /** @type {?} */\n    const reducerFactory = Array.isArray(metaReducers) && metaReducers.length > 0\n        ? compose(...metaReducers)\n        : (/**\n         * @param {?} r\n         * @return {?}\n         */\n        (r) => r);\n    return (/**\n     * @param {?} reducer\n     * @param {?=} initialState\n     * @return {?}\n     */\n    (reducer, initialState) => {\n        reducer = reducerFactory(reducer);\n        return (/**\n         * @param {?} state\n         * @param {?} action\n         * @return {?}\n         */\n        (state, action) => {\n            state = state === undefined ? initialState : state;\n            return reducer(state, action);\n        });\n    });\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: modules/store/src/reducer_manager.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @abstract\n */\nclass ReducerObservable extends Observable {\n}\n/**\n * @abstract\n */\nclass ReducerManagerDispatcher extends ActionsSubject {\n}\n/** @type {?} */\nconst UPDATE = (/** @type {?} */ ('@ngrx/store/update-reducers'));\nclass ReducerManager extends BehaviorSubject {\n    /**\n     * @param {?} dispatcher\n     * @param {?} initialState\n     * @param {?} reducers\n     * @param {?} reducerFactory\n     */\n    constructor(dispatcher, initialState, reducers, reducerFactory) {\n        super(reducerFactory(reducers, initialState));\n        this.dispatcher = dispatcher;\n        this.initialState = initialState;\n        this.reducers = reducers;\n        this.reducerFactory = reducerFactory;\n    }\n    /**\n     * @param {?} feature\n     * @return {?}\n     */\n    addFeature(feature) {\n        this.addFeatures([feature]);\n    }\n    /**\n     * @param {?} features\n     * @return {?}\n     */\n    addFeatures(features) {\n        /** @type {?} */\n        const reducers = features.reduce((/**\n         * @param {?} reducerDict\n         * @param {?} __1\n         * @return {?}\n         */\n        (reducerDict, { reducers, reducerFactory, metaReducers, initialState, key }) => {\n            /** @type {?} */\n            const reducer = typeof reducers === 'function'\n                ? createFeatureReducerFactory(metaReducers)(reducers, initialState)\n                : createReducerFactory(reducerFactory, metaReducers)(reducers, initialState);\n            reducerDict[key] = reducer;\n            return reducerDict;\n        }), (/** @type {?} */ ({})));\n        this.addReducers(reducers);\n    }\n    /**\n     * @param {?} feature\n     * @return {?}\n     */\n    removeFeature(feature) {\n        this.removeFeatures([feature]);\n    }\n    /**\n     * @param {?} features\n     * @return {?}\n     */\n    removeFeatures(features) {\n        this.removeReducers(features.map((/**\n         * @param {?} p\n         * @return {?}\n         */\n        p => p.key)));\n    }\n    /**\n     * @param {?} key\n     * @param {?} reducer\n     * @return {?}\n     */\n    addReducer(key, reducer) {\n        this.addReducers({ [key]: reducer });\n    }\n    /**\n     * @param {?} reducers\n     * @return {?}\n     */\n    addReducers(reducers) {\n        this.reducers = Object.assign(Object.assign({}, this.reducers), reducers);\n        this.updateReducers(Object.keys(reducers));\n    }\n    /**\n     * @param {?} featureKey\n     * @return {?}\n     */\n    removeReducer(featureKey) {\n        this.removeReducers([featureKey]);\n    }\n    /**\n     * @param {?} featureKeys\n     * @return {?}\n     */\n    removeReducers(featureKeys) {\n        featureKeys.forEach((/**\n         * @param {?} key\n         * @return {?}\n         */\n        key => {\n            this.reducers = (/** @type {?} */ (omit(this.reducers, key) /*TODO(#823)*/));\n        }));\n        this.updateReducers(featureKeys);\n    }\n    /**\n     * @private\n     * @param {?} featureKeys\n     * @return {?}\n     */\n    updateReducers(featureKeys) {\n        this.next(this.reducerFactory(this.reducers, this.initialState));\n        this.dispatcher.next((/** @type {?} */ ({\n            type: UPDATE,\n            features: featureKeys,\n        })));\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this.complete();\n    }\n}\nReducerManager.decorators = [\n    { type: Injectable }\n];\n/** @nocollapse */\nReducerManager.ctorParameters = () => [\n    { type: ReducerManagerDispatcher },\n    { type: undefined, decorators: [{ type: Inject, args: [INITIAL_STATE,] }] },\n    { type: undefined, decorators: [{ type: Inject, args: [INITIAL_REDUCERS,] }] },\n    { type: undefined, decorators: [{ type: Inject, args: [REDUCER_FACTORY,] }] }\n];\nif (false) {\n    /**\n     * @type {?}\n     * @private\n     */\n    ReducerManager.prototype.dispatcher;\n    /**\n     * @type {?}\n     * @private\n     */\n    ReducerManager.prototype.initialState;\n    /**\n     * @type {?}\n     * @private\n     */\n    ReducerManager.prototype.reducers;\n    /**\n     * @type {?}\n     * @private\n     */\n    ReducerManager.prototype.reducerFactory;\n}\n/** @type {?} */\nconst REDUCER_MANAGER_PROVIDERS = [\n    ReducerManager,\n    { provide: ReducerObservable, useExisting: ReducerManager },\n    { provide: ReducerManagerDispatcher, useExisting: ActionsSubject },\n];\n\n/**\n * @fileoverview added by tsickle\n * Generated from: modules/store/src/scanned_actions_subject.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass ScannedActionsSubject extends Subject {\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this.complete();\n    }\n}\nScannedActionsSubject.decorators = [\n    { type: Injectable }\n];\n/** @type {?} */\nconst SCANNED_ACTIONS_SUBJECT_PROVIDERS = [\n    ScannedActionsSubject,\n];\n\n/**\n * @fileoverview added by tsickle\n * Generated from: modules/store/src/state.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @abstract\n */\nclass StateObservable extends Observable {\n}\n/**\n * @template T\n */\nclass State extends BehaviorSubject {\n    /**\n     * @param {?} actions$\n     * @param {?} reducer$\n     * @param {?} scannedActions\n     * @param {?} initialState\n     */\n    constructor(actions$, reducer$, scannedActions, initialState) {\n        super(initialState);\n        /** @type {?} */\n        const actionsOnQueue$ = actions$.pipe(observeOn(queueScheduler));\n        /** @type {?} */\n        const withLatestReducer$ = actionsOnQueue$.pipe(withLatestFrom(reducer$));\n        /** @type {?} */\n        const seed = { state: initialState };\n        /** @type {?} */\n        const stateAndAction$ = withLatestReducer$.pipe(scan(reduceState, seed));\n        this.stateSubscription = stateAndAction$.subscribe((/**\n         * @param {?} __0\n         * @return {?}\n         */\n        ({ state, action }) => {\n            this.next(state);\n            scannedActions.next(action);\n        }));\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this.stateSubscription.unsubscribe();\n        this.complete();\n    }\n}\nState.INIT = INIT;\nState.decorators = [\n    { type: Injectable }\n];\n/** @nocollapse */\nState.ctorParameters = () => [\n    { type: ActionsSubject },\n    { type: ReducerObservable },\n    { type: ScannedActionsSubject },\n    { type: undefined, decorators: [{ type: Inject, args: [INITIAL_STATE,] }] }\n];\nif (false) {\n    /** @type {?} */\n    State.INIT;\n    /**\n     * @type {?}\n     * @private\n     */\n    State.prototype.stateSubscription;\n}\n/**\n * @template T, V\n * @param {?=} stateActionPair\n * @param {?=} __1\n * @return {?}\n */\nfunction reduceState(stateActionPair = { state: undefined }, [action, reducer]) {\n    const { state } = stateActionPair;\n    return { state: reducer(state, action), action };\n}\n/** @type {?} */\nconst STATE_PROVIDERS = [\n    State,\n    { provide: StateObservable, useExisting: State },\n];\n\n/**\n * @fileoverview added by tsickle\n * Generated from: modules/store/src/store.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @template T\n */\nclass Store extends Observable {\n    /**\n     * @param {?} state$\n     * @param {?} actionsObserver\n     * @param {?} reducerManager\n     */\n    constructor(state$, actionsObserver, reducerManager) {\n        super();\n        this.actionsObserver = actionsObserver;\n        this.reducerManager = reducerManager;\n        this.source = state$;\n    }\n    /**\n     * @template Props, K\n     * @param {?} pathOrMapFn\n     * @param {...?} paths\n     * @return {?}\n     */\n    select(pathOrMapFn, ...paths) {\n        return ((/** @type {?} */ (select))).call(null, pathOrMapFn, ...paths)(this);\n    }\n    /**\n     * @template R\n     * @param {?} operator\n     * @return {?}\n     */\n    lift(operator) {\n        /** @type {?} */\n        const store = new Store(this, this.actionsObserver, this.reducerManager);\n        store.operator = operator;\n        return store;\n    }\n    /**\n     * @template V\n     * @param {?} action\n     * @return {?}\n     */\n    dispatch(action) {\n        this.actionsObserver.next(action);\n    }\n    /**\n     * @param {?} action\n     * @return {?}\n     */\n    next(action) {\n        this.actionsObserver.next(action);\n    }\n    /**\n     * @param {?} err\n     * @return {?}\n     */\n    error(err) {\n        this.actionsObserver.error(err);\n    }\n    /**\n     * @return {?}\n     */\n    complete() {\n        this.actionsObserver.complete();\n    }\n    /**\n     * @template State, Actions\n     * @param {?} key\n     * @param {?} reducer\n     * @return {?}\n     */\n    addReducer(key, reducer) {\n        this.reducerManager.addReducer(key, reducer);\n    }\n    /**\n     * @template Key\n     * @param {?} key\n     * @return {?}\n     */\n    removeReducer(key) {\n        this.reducerManager.removeReducer(key);\n    }\n}\nStore.decorators = [\n    { type: Injectable }\n];\n/** @nocollapse */\nStore.ctorParameters = () => [\n    { type: StateObservable },\n    { type: ActionsSubject },\n    { type: ReducerManager }\n];\nif (false) {\n    /**\n     * @type {?}\n     * @private\n     */\n    Store.prototype.actionsObserver;\n    /**\n     * @type {?}\n     * @private\n     */\n    Store.prototype.reducerManager;\n}\n/** @type {?} */\nconst STORE_PROVIDERS = [Store];\n/**\n * @template T, Props, K\n * @param {?} pathOrMapFn\n * @param {?=} propsOrPath\n * @param {...?} paths\n * @return {?}\n */\nfunction select(pathOrMapFn, propsOrPath, ...paths) {\n    return (/**\n     * @param {?} source$\n     * @return {?}\n     */\n    function selectOperator(source$) {\n        /** @type {?} */\n        let mapped$;\n        if (typeof pathOrMapFn === 'string') {\n            /** @type {?} */\n            const pathSlices = [(/** @type {?} */ (propsOrPath)), ...paths].filter(Boolean);\n            mapped$ = source$.pipe(pluck(pathOrMapFn, ...pathSlices));\n        }\n        else if (typeof pathOrMapFn === 'function') {\n            mapped$ = source$.pipe(map((/**\n             * @param {?} source\n             * @return {?}\n             */\n            source => pathOrMapFn(source, (/** @type {?} */ (propsOrPath))))));\n        }\n        else {\n            throw new TypeError(`Unexpected type '${typeof pathOrMapFn}' in select operator,` +\n                ` expected 'string' or 'function'`);\n        }\n        return mapped$.pipe(distinctUntilChanged());\n    });\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: modules/store/src/selector.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @record\n * @template State, Result, ProjectorFn\n */\nfunction MemoizedSelector() { }\nif (false) {\n    /** @type {?} */\n    MemoizedSelector.prototype.projector;\n    /** @type {?} */\n    MemoizedSelector.prototype.setResult;\n    /** @type {?} */\n    MemoizedSelector.prototype.clearResult;\n    /**\n     * @return {?}\n     */\n    MemoizedSelector.prototype.release = function () { };\n}\n/**\n * @record\n * @template State, Props, Result, ProjectorFn\n */\nfunction MemoizedSelectorWithProps() { }\nif (false) {\n    /** @type {?} */\n    MemoizedSelectorWithProps.prototype.projector;\n    /** @type {?} */\n    MemoizedSelectorWithProps.prototype.setResult;\n    /** @type {?} */\n    MemoizedSelectorWithProps.prototype.clearResult;\n    /**\n     * @return {?}\n     */\n    MemoizedSelectorWithProps.prototype.release = function () { };\n}\n/**\n * @param {?} a\n * @param {?} b\n * @return {?}\n */\nfunction isEqualCheck(a, b) {\n    return a === b;\n}\n/**\n * @param {?} args\n * @param {?} lastArguments\n * @param {?} comparator\n * @return {?}\n */\nfunction isArgumentsChanged(args, lastArguments, comparator) {\n    for (let i = 0; i < args.length; i++) {\n        if (!comparator(args[i], lastArguments[i])) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * @param {?} projectionFn\n * @param {?} isResultEqual\n * @return {?}\n */\nfunction resultMemoize(projectionFn, isResultEqual) {\n    return defaultMemoize(projectionFn, isEqualCheck, isResultEqual);\n}\n/**\n * @param {?} projectionFn\n * @param {?=} isArgumentsEqual\n * @param {?=} isResultEqual\n * @return {?}\n */\nfunction defaultMemoize(projectionFn, isArgumentsEqual = isEqualCheck, isResultEqual = isEqualCheck) {\n    /** @type {?} */\n    let lastArguments = null;\n    // tslint:disable-next-line:no-any anything could be the result.\n    /** @type {?} */\n    let lastResult = null;\n    /** @type {?} */\n    let overrideResult;\n    /**\n     * @return {?}\n     */\n    function reset() {\n        lastArguments = null;\n        lastResult = null;\n    }\n    /**\n     * @param {?=} result\n     * @return {?}\n     */\n    function setResult(result = undefined) {\n        overrideResult = { result };\n    }\n    /**\n     * @return {?}\n     */\n    function clearResult() {\n        overrideResult = undefined;\n    }\n    // tslint:disable-next-line:no-any anything could be the result.\n    /**\n     * @return {?}\n     */\n    function memoized() {\n        if (overrideResult !== undefined) {\n            return overrideResult.result;\n        }\n        if (!lastArguments) {\n            lastResult = projectionFn.apply(null, (/** @type {?} */ (arguments)));\n            lastArguments = arguments;\n            return lastResult;\n        }\n        if (!isArgumentsChanged(arguments, lastArguments, isArgumentsEqual)) {\n            return lastResult;\n        }\n        /** @type {?} */\n        const newResult = projectionFn.apply(null, (/** @type {?} */ (arguments)));\n        lastArguments = arguments;\n        if (isResultEqual(lastResult, newResult)) {\n            return lastResult;\n        }\n        lastResult = newResult;\n        return newResult;\n    }\n    return { memoized, reset, setResult, clearResult };\n}\n/**\n * @param {...?} input\n * @return {?}\n */\nfunction createSelector(...input) {\n    return createSelectorFactory(defaultMemoize)(...input);\n}\n/**\n * @param {?} state\n * @param {?} selectors\n * @param {?} props\n * @param {?} memoizedProjector\n * @return {?}\n */\nfunction defaultStateFn(state, selectors, props, memoizedProjector) {\n    if (props === undefined) {\n        /** @type {?} */\n        const args = ((/** @type {?} */ (selectors))).map((/**\n         * @param {?} fn\n         * @return {?}\n         */\n        fn => fn(state)));\n        return memoizedProjector.memoized.apply(null, args);\n    }\n    /** @type {?} */\n    const args = ((/** @type {?} */ (selectors))).map((/**\n     * @param {?} fn\n     * @return {?}\n     */\n    fn => fn(state, props)));\n    return memoizedProjector.memoized.apply(null, [...args, props]);\n}\n/**\n * @param {?} memoize\n * @param {?=} options\n * @return {?}\n */\nfunction createSelectorFactory(memoize, options = {\n    stateFn: defaultStateFn,\n}) {\n    return (/**\n     * @param {...?} input\n     * @return {?}\n     */\n    function (...input) {\n        /** @type {?} */\n        let args = input;\n        if (Array.isArray(args[0])) {\n            const [head, ...tail] = args;\n            args = [...head, ...tail];\n        }\n        /** @type {?} */\n        const selectors = args.slice(0, args.length - 1);\n        /** @type {?} */\n        const projector = args[args.length - 1];\n        /** @type {?} */\n        const memoizedSelectors = selectors.filter((/**\n         * @param {?} selector\n         * @return {?}\n         */\n        (selector) => selector.release && typeof selector.release === 'function'));\n        /** @type {?} */\n        const memoizedProjector = memoize((/**\n         * @param {...?} selectors\n         * @return {?}\n         */\n        function (...selectors) {\n            return projector.apply(null, selectors);\n        }));\n        /** @type {?} */\n        const memoizedState = defaultMemoize((/**\n         * @param {?} state\n         * @param {?} props\n         * @return {?}\n         */\n        function (state, props) {\n            return options.stateFn.apply(null, [\n                state,\n                selectors,\n                props,\n                memoizedProjector,\n            ]);\n        }));\n        /**\n         * @return {?}\n         */\n        function release() {\n            memoizedState.reset();\n            memoizedProjector.reset();\n            memoizedSelectors.forEach((/**\n             * @param {?} selector\n             * @return {?}\n             */\n            selector => selector.release()));\n        }\n        return Object.assign(memoizedState.memoized, {\n            release,\n            projector: memoizedProjector.memoized,\n            setResult: memoizedState.setResult,\n            clearResult: memoizedState.clearResult,\n        });\n    });\n}\n/**\n * @param {?} featureName\n * @return {?}\n */\nfunction createFeatureSelector(featureName) {\n    return createSelector((/**\n     * @param {?} state\n     * @return {?}\n     */\n    (state) => {\n        /** @type {?} */\n        const featureState = state[featureName];\n        if (isDevMode() && !(featureName in state)) {\n            console.warn(`@ngrx/store: The feature name \\\"${featureName}\\\" does ` +\n                'not exist in the state, therefore createFeatureSelector ' +\n                'cannot access it.  Be sure it is imported in a loaded module ' +\n                `using StoreModule.forRoot('${featureName}', ...) or ` +\n                `StoreModule.forFeature('${featureName}', ...).  If the default ` +\n                'state is intended to be undefined, as is the case with router ' +\n                'state, this development-only warning message can be ignored.');\n        }\n        return featureState;\n    }), (/**\n     * @param {?} featureState\n     * @return {?}\n     */\n    (featureState) => featureState));\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: modules/store/src/meta-reducers/utils.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst RUNTIME_CHECK_URL = 'https://ngrx.io/guide/store/configuration/runtime-checks';\n/**\n * @param {?} target\n * @return {?}\n */\nfunction isUndefined(target) {\n    return target === undefined;\n}\n/**\n * @param {?} target\n * @return {?}\n */\nfunction isNull(target) {\n    return target === null;\n}\n/**\n * @param {?} target\n * @return {?}\n */\nfunction isArray(target) {\n    return Array.isArray(target);\n}\n/**\n * @param {?} target\n * @return {?}\n */\nfunction isString(target) {\n    return typeof target === 'string';\n}\n/**\n * @param {?} target\n * @return {?}\n */\nfunction isBoolean(target) {\n    return typeof target === 'boolean';\n}\n/**\n * @param {?} target\n * @return {?}\n */\nfunction isNumber(target) {\n    return typeof target === 'number';\n}\n/**\n * @param {?} target\n * @return {?}\n */\nfunction isObjectLike(target) {\n    return typeof target === 'object' && target !== null;\n}\n/**\n * @param {?} target\n * @return {?}\n */\nfunction isObject(target) {\n    return isObjectLike(target) && !isArray(target);\n}\n/**\n * @param {?} target\n * @return {?}\n */\nfunction isPlainObject(target) {\n    if (!isObject(target)) {\n        return false;\n    }\n    /** @type {?} */\n    const targetPrototype = Object.getPrototypeOf(target);\n    return targetPrototype === Object.prototype || targetPrototype === null;\n}\n/**\n * @param {?} target\n * @return {?}\n */\nfunction isFunction(target) {\n    return typeof target === 'function';\n}\n/**\n * @param {?} target\n * @param {?} propertyName\n * @return {?}\n */\nfunction hasOwnProperty(target, propertyName) {\n    return Object.prototype.hasOwnProperty.call(target, propertyName);\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: modules/store/src/meta-reducers/immutability_reducer.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} reducer\n * @param {?} checks\n * @return {?}\n */\nfunction immutabilityCheckMetaReducer(reducer, checks) {\n    return (/**\n     * @param {?} state\n     * @param {?} action\n     * @return {?}\n     */\n    function (state, action) {\n        /** @type {?} */\n        const act = checks.action(action) ? freeze(action) : action;\n        /** @type {?} */\n        const nextState = reducer(state, act);\n        return checks.state() ? freeze(nextState) : nextState;\n    });\n}\n/**\n * @param {?} target\n * @return {?}\n */\nfunction freeze(target) {\n    Object.freeze(target);\n    /** @type {?} */\n    const targetIsFunction = isFunction(target);\n    Object.getOwnPropertyNames(target).forEach((/**\n     * @param {?} prop\n     * @return {?}\n     */\n    prop => {\n        if (hasOwnProperty(target, prop) &&\n            (targetIsFunction\n                ? prop !== 'caller' && prop !== 'callee' && prop !== 'arguments'\n                : true)) {\n            /** @type {?} */\n            const propValue = target[prop];\n            if ((isObjectLike(propValue) || isFunction(propValue)) &&\n                !Object.isFrozen(propValue)) {\n                freeze(propValue);\n            }\n        }\n    }));\n    return target;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: modules/store/src/meta-reducers/serialization_reducer.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} reducer\n * @param {?} checks\n * @return {?}\n */\nfunction serializationCheckMetaReducer(reducer, checks) {\n    return (/**\n     * @param {?} state\n     * @param {?} action\n     * @return {?}\n     */\n    function (state, action) {\n        if (checks.action(action)) {\n            /** @type {?} */\n            const unserializableAction = getUnserializable(action);\n            throwIfUnserializable(unserializableAction, 'action');\n        }\n        /** @type {?} */\n        const nextState = reducer(state, action);\n        if (checks.state()) {\n            /** @type {?} */\n            const unserializableState = getUnserializable(nextState);\n            throwIfUnserializable(unserializableState, 'state');\n        }\n        return nextState;\n    });\n}\n/**\n * @param {?=} target\n * @param {?=} path\n * @return {?}\n */\nfunction getUnserializable(target, path = []) {\n    // Guard against undefined and null, e.g. a reducer that returns undefined\n    if ((isUndefined(target) || isNull(target)) && path.length === 0) {\n        return {\n            path: ['root'],\n            value: target,\n        };\n    }\n    /** @type {?} */\n    const keys = Object.keys(target);\n    return keys.reduce((/**\n     * @param {?} result\n     * @param {?} key\n     * @return {?}\n     */\n    (result, key) => {\n        if (result) {\n            return result;\n        }\n        /** @type {?} */\n        const value = ((/** @type {?} */ (target)))[key];\n        if (isUndefined(value) ||\n            isNull(value) ||\n            isNumber(value) ||\n            isBoolean(value) ||\n            isString(value) ||\n            isArray(value)) {\n            return false;\n        }\n        if (isPlainObject(value)) {\n            return getUnserializable(value, [...path, key]);\n        }\n        return {\n            path: [...path, key],\n            value,\n        };\n    }), false);\n}\n/**\n * @param {?} unserializable\n * @param {?} context\n * @return {?}\n */\nfunction throwIfUnserializable(unserializable, context) {\n    if (unserializable === false) {\n        return;\n    }\n    /** @type {?} */\n    const unserializablePath = unserializable.path.join('.');\n    /** @type {?} */\n    const error = new Error(`Detected unserializable ${context} at \"${unserializablePath}\". ${RUNTIME_CHECK_URL}#strict${context}serializability`);\n    error.value = unserializable.value;\n    error.unserializablePath = unserializablePath;\n    throw error;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: modules/store/src/meta-reducers/inNgZoneAssert_reducer.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} reducer\n * @param {?} checks\n * @return {?}\n */\nfunction inNgZoneAssertMetaReducer(reducer, checks) {\n    return (/**\n     * @param {?} state\n     * @param {?} action\n     * @return {?}\n     */\n    function (state, action) {\n        if (checks.action(action) && !NgZone.isInAngularZone()) {\n            throw new Error(`Action '${action.type}' running outside NgZone. ${RUNTIME_CHECK_URL}#strictactionwithinngzone`);\n        }\n        return reducer(state, action);\n    });\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: modules/store/src/meta-reducers/index.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: modules/store/src/runtime_checks.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?=} runtimeChecks\n * @return {?}\n */\nfunction createActiveRuntimeChecks(runtimeChecks) {\n    if (isDevMode()) {\n        return Object.assign({ strictStateSerializability: false, strictActionSerializability: false, strictStateImmutability: true, strictActionImmutability: true, strictActionWithinNgZone: false }, runtimeChecks);\n    }\n    return {\n        strictStateSerializability: false,\n        strictActionSerializability: false,\n        strictStateImmutability: false,\n        strictActionImmutability: false,\n        strictActionWithinNgZone: false,\n    };\n}\n/**\n * @param {?} __0\n * @return {?}\n */\nfunction createSerializationCheckMetaReducer({ strictActionSerializability, strictStateSerializability, }) {\n    return (/**\n     * @param {?} reducer\n     * @return {?}\n     */\n    reducer => strictActionSerializability || strictStateSerializability\n        ? serializationCheckMetaReducer(reducer, {\n            action: (/**\n             * @param {?} action\n             * @return {?}\n             */\n            action => strictActionSerializability && !ignoreNgrxAction(action)),\n            state: (/**\n             * @return {?}\n             */\n            () => strictStateSerializability),\n        })\n        : reducer);\n}\n/**\n * @param {?} __0\n * @return {?}\n */\nfunction createImmutabilityCheckMetaReducer({ strictActionImmutability, strictStateImmutability, }) {\n    return (/**\n     * @param {?} reducer\n     * @return {?}\n     */\n    reducer => strictActionImmutability || strictStateImmutability\n        ? immutabilityCheckMetaReducer(reducer, {\n            action: (/**\n             * @param {?} action\n             * @return {?}\n             */\n            action => strictActionImmutability && !ignoreNgrxAction(action)),\n            state: (/**\n             * @return {?}\n             */\n            () => strictStateImmutability),\n        })\n        : reducer);\n}\n/**\n * @param {?} action\n * @return {?}\n */\nfunction ignoreNgrxAction(action) {\n    return action.type.startsWith('@ngrx');\n}\n/**\n * @param {?} __0\n * @return {?}\n */\nfunction createInNgZoneCheckMetaReducer({ strictActionWithinNgZone, }) {\n    return (/**\n     * @param {?} reducer\n     * @return {?}\n     */\n    reducer => strictActionWithinNgZone\n        ? inNgZoneAssertMetaReducer(reducer, {\n            action: (/**\n             * @param {?} action\n             * @return {?}\n             */\n            action => strictActionWithinNgZone && !ignoreNgrxAction(action)),\n        })\n        : reducer);\n}\n/**\n * @param {?=} runtimeChecks\n * @return {?}\n */\nfunction provideRuntimeChecks(runtimeChecks) {\n    return [\n        {\n            provide: _USER_RUNTIME_CHECKS,\n            useValue: runtimeChecks,\n        },\n        {\n            provide: USER_RUNTIME_CHECKS,\n            useFactory: _runtimeChecksFactory,\n            deps: [_USER_RUNTIME_CHECKS],\n        },\n        {\n            provide: _ACTIVE_RUNTIME_CHECKS,\n            deps: [USER_RUNTIME_CHECKS],\n            useFactory: createActiveRuntimeChecks,\n        },\n        {\n            provide: META_REDUCERS,\n            multi: true,\n            deps: [_ACTIVE_RUNTIME_CHECKS],\n            useFactory: createImmutabilityCheckMetaReducer,\n        },\n        {\n            provide: META_REDUCERS,\n            multi: true,\n            deps: [_ACTIVE_RUNTIME_CHECKS],\n            useFactory: createSerializationCheckMetaReducer,\n        },\n        {\n            provide: META_REDUCERS,\n            multi: true,\n            deps: [_ACTIVE_RUNTIME_CHECKS],\n            useFactory: createInNgZoneCheckMetaReducer,\n        },\n    ];\n}\n/**\n * @param {?} runtimeChecks\n * @return {?}\n */\nfunction _runtimeChecksFactory(runtimeChecks) {\n    return runtimeChecks;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: modules/store/src/store_module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass StoreRootModule {\n    /**\n     * @param {?} actions$\n     * @param {?} reducer$\n     * @param {?} scannedActions$\n     * @param {?} store\n     * @param {?} guard\n     */\n    constructor(actions$, reducer$, scannedActions$, store, guard) {\n    }\n}\nStoreRootModule.decorators = [\n    { type: NgModule, args: [{},] }\n];\n/** @nocollapse */\nStoreRootModule.ctorParameters = () => [\n    { type: ActionsSubject },\n    { type: ReducerObservable },\n    { type: ScannedActionsSubject },\n    { type: Store },\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [_ROOT_STORE_GUARD,] }] }\n];\nclass StoreFeatureModule {\n    /**\n     * @param {?} features\n     * @param {?} featureReducers\n     * @param {?} reducerManager\n     * @param {?} root\n     */\n    constructor(features, featureReducers, reducerManager, root) {\n        this.features = features;\n        this.featureReducers = featureReducers;\n        this.reducerManager = reducerManager;\n        /** @type {?} */\n        const feats = features.map((/**\n         * @param {?} feature\n         * @param {?} index\n         * @return {?}\n         */\n        (feature, index) => {\n            /** @type {?} */\n            const featureReducerCollection = featureReducers.shift();\n            /** @type {?} */\n            const reducers = (/** @type {?} */ (featureReducerCollection /*TODO(#823)*/))[index];\n            return Object.assign(Object.assign({}, feature), { reducers, initialState: _initialStateFactory(feature.initialState) });\n        }));\n        reducerManager.addFeatures(feats);\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this.reducerManager.removeFeatures(this.features);\n    }\n}\nStoreFeatureModule.decorators = [\n    { type: NgModule, args: [{},] }\n];\n/** @nocollapse */\nStoreFeatureModule.ctorParameters = () => [\n    { type: Array, decorators: [{ type: Inject, args: [_STORE_FEATURES,] }] },\n    { type: Array, decorators: [{ type: Inject, args: [FEATURE_REDUCERS,] }] },\n    { type: ReducerManager },\n    { type: StoreRootModule }\n];\nif (false) {\n    /**\n     * @type {?}\n     * @private\n     */\n    StoreFeatureModule.prototype.features;\n    /**\n     * @type {?}\n     * @private\n     */\n    StoreFeatureModule.prototype.featureReducers;\n    /**\n     * @type {?}\n     * @private\n     */\n    StoreFeatureModule.prototype.reducerManager;\n}\n/**\n * @record\n * @template T, V\n */\nfunction StoreConfig() { }\nif (false) {\n    /** @type {?|undefined} */\n    StoreConfig.prototype.initialState;\n    /** @type {?|undefined} */\n    StoreConfig.prototype.reducerFactory;\n    /** @type {?|undefined} */\n    StoreConfig.prototype.metaReducers;\n}\n/**\n * @record\n * @template T, V\n */\nfunction RootStoreConfig() { }\nif (false) {\n    /** @type {?|undefined} */\n    RootStoreConfig.prototype.runtimeChecks;\n}\nclass StoreModule {\n    /**\n     * @param {?} reducers\n     * @param {?=} config\n     * @return {?}\n     */\n    static forRoot(reducers, config = {}) {\n        return {\n            ngModule: StoreRootModule,\n            providers: [\n                {\n                    provide: _ROOT_STORE_GUARD,\n                    useFactory: _provideForRootGuard,\n                    deps: [[Store, new Optional(), new SkipSelf()]],\n                },\n                { provide: _INITIAL_STATE, useValue: config.initialState },\n                {\n                    provide: INITIAL_STATE,\n                    useFactory: _initialStateFactory,\n                    deps: [_INITIAL_STATE],\n                },\n                { provide: _INITIAL_REDUCERS, useValue: reducers },\n                {\n                    provide: _STORE_REDUCERS,\n                    useExisting: reducers instanceof InjectionToken ? reducers : _INITIAL_REDUCERS,\n                },\n                {\n                    provide: INITIAL_REDUCERS,\n                    deps: [Injector, _INITIAL_REDUCERS, [new Inject(_STORE_REDUCERS)]],\n                    useFactory: _createStoreReducers,\n                },\n                {\n                    provide: USER_PROVIDED_META_REDUCERS,\n                    useValue: config.metaReducers ? config.metaReducers : [],\n                },\n                {\n                    provide: _RESOLVED_META_REDUCERS,\n                    deps: [META_REDUCERS, USER_PROVIDED_META_REDUCERS],\n                    useFactory: _concatMetaReducers,\n                },\n                {\n                    provide: _REDUCER_FACTORY,\n                    useValue: config.reducerFactory\n                        ? config.reducerFactory\n                        : combineReducers,\n                },\n                {\n                    provide: REDUCER_FACTORY,\n                    deps: [_REDUCER_FACTORY, _RESOLVED_META_REDUCERS],\n                    useFactory: createReducerFactory,\n                },\n                ACTIONS_SUBJECT_PROVIDERS,\n                REDUCER_MANAGER_PROVIDERS,\n                SCANNED_ACTIONS_SUBJECT_PROVIDERS,\n                STATE_PROVIDERS,\n                STORE_PROVIDERS,\n                provideRuntimeChecks(config.runtimeChecks),\n            ],\n        };\n    }\n    /**\n     * @param {?} featureName\n     * @param {?} reducers\n     * @param {?=} config\n     * @return {?}\n     */\n    static forFeature(featureName, reducers, config = {}) {\n        return {\n            ngModule: StoreFeatureModule,\n            providers: [\n                {\n                    provide: _FEATURE_CONFIGS,\n                    multi: true,\n                    useValue: config,\n                },\n                {\n                    provide: STORE_FEATURES,\n                    multi: true,\n                    useValue: {\n                        key: featureName,\n                        reducerFactory: !(config instanceof InjectionToken) && config.reducerFactory\n                            ? config.reducerFactory\n                            : combineReducers,\n                        metaReducers: !(config instanceof InjectionToken) && config.metaReducers\n                            ? config.metaReducers\n                            : [],\n                        initialState: !(config instanceof InjectionToken) && config.initialState\n                            ? config.initialState\n                            : undefined,\n                    },\n                },\n                {\n                    provide: _STORE_FEATURES,\n                    deps: [Injector, _FEATURE_CONFIGS, STORE_FEATURES],\n                    useFactory: _createFeatureStore,\n                },\n                { provide: _FEATURE_REDUCERS, multi: true, useValue: reducers },\n                {\n                    provide: _FEATURE_REDUCERS_TOKEN,\n                    multi: true,\n                    useExisting: reducers instanceof InjectionToken ? reducers : _FEATURE_REDUCERS,\n                },\n                {\n                    provide: FEATURE_REDUCERS,\n                    multi: true,\n                    deps: [\n                        Injector,\n                        _FEATURE_REDUCERS,\n                        [new Inject(_FEATURE_REDUCERS_TOKEN)],\n                    ],\n                    useFactory: _createFeatureReducers,\n                },\n            ],\n        };\n    }\n}\nStoreModule.decorators = [\n    { type: NgModule, args: [{},] }\n];\n/**\n * @param {?} injector\n * @param {?} reducers\n * @return {?}\n */\nfunction _createStoreReducers(injector, reducers) {\n    return reducers instanceof InjectionToken ? injector.get(reducers) : reducers;\n}\n/**\n * @param {?} injector\n * @param {?} configs\n * @param {?} featureStores\n * @return {?}\n */\nfunction _createFeatureStore(injector, configs, featureStores) {\n    return featureStores.map((/**\n     * @param {?} feat\n     * @param {?} index\n     * @return {?}\n     */\n    (feat, index) => {\n        if (configs[index] instanceof InjectionToken) {\n            /** @type {?} */\n            const conf = injector.get(configs[index]);\n            return {\n                key: feat.key,\n                reducerFactory: conf.reducerFactory\n                    ? conf.reducerFactory\n                    : combineReducers,\n                metaReducers: conf.metaReducers ? conf.metaReducers : [],\n                initialState: conf.initialState,\n            };\n        }\n        return feat;\n    }));\n}\n/**\n * @param {?} injector\n * @param {?} reducerCollection\n * @return {?}\n */\nfunction _createFeatureReducers(injector, reducerCollection) {\n    /** @type {?} */\n    const reducers = reducerCollection.map((/**\n     * @param {?} reducer\n     * @return {?}\n     */\n    reducer => {\n        return reducer instanceof InjectionToken ? injector.get(reducer) : reducer;\n    }));\n    return reducers;\n}\n/**\n * @param {?} initialState\n * @return {?}\n */\nfunction _initialStateFactory(initialState) {\n    if (typeof initialState === 'function') {\n        return initialState();\n    }\n    return initialState;\n}\n/**\n * @param {?} metaReducers\n * @param {?} userProvidedMetaReducers\n * @return {?}\n */\nfunction _concatMetaReducers(metaReducers, userProvidedMetaReducers) {\n    return metaReducers.concat(userProvidedMetaReducers);\n}\n/**\n * @param {?} store\n * @return {?}\n */\nfunction _provideForRootGuard(store) {\n    if (store) {\n        throw new TypeError(`StoreModule.forRoot() called twice. Feature modules should use StoreModule.forFeature() instead.`);\n    }\n    return 'guarded';\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: modules/store/src/reducer_creator.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @record\n * @template S\n */\nfunction On() { }\nif (false) {\n    /** @type {?} */\n    On.prototype.reducer;\n    /** @type {?} */\n    On.prototype.types;\n}\n/**\n * @record\n * @template S, C\n */\nfunction OnReducer() { }\n/**\n * \\@description\n * Associates actions with a given state change function.\n * A state change function must be provided as the last parameter.\n *\n * @param {...?} args `ActionCreator`'s followed by a state change function.\n *\n * **To maintain type-safety**: pass 10 or less `ActionCreator`'s.\n * @return {?} an association of action types with a state change function.\n */\nfunction on(...args) {\n    /** @type {?} */\n    const reducer = (/** @type {?} */ (args.pop()));\n    /** @type {?} */\n    const types = args.reduce((/**\n     * @param {?} result\n     * @param {?} creator\n     * @return {?}\n     */\n    (result, creator) => [...result, ((/** @type {?} */ (creator))).type]), (/** @type {?} */ ([])));\n    return { reducer, types };\n}\n/**\n * \\@description\n * Creates a reducer function to handle state transitions.\n *\n * Reducer creators reduce the explicitness of reducer functions with switch statements.\n *\n * \\@usageNotes\n *\n * - Must be used with `ActionCreator`'s (returned by `createAction`).  Cannot be used with class-based action creators.\n * - An action can be associated with multiple state change functions. In this case the functions will be executed in the specified order.\n * - The returned `ActionReducer` should additionally be returned from an exported `reducer` function.\n * This is because [function calls are not supported](https://angular.io/guide/aot-compiler#function-calls-are-not-supported) by the AOT compiler.\n *\n * **Declaring a reducer creator with an exported reducer function**\n *\n * ```ts\n * const featureReducer = createReducer(\n *   initialState,\n *   on(\n *     featureActions.actionOne,\n *     featureActions.actionTwo,\n *     (state, { updatedValue }) => ({ ...state, prop: updatedValue })\n *   ),\n *   on(featureActions.actionThree, () => initialState);\n * );\n *\n * export function reducer(state: State | undefined, action: Action) {\n *   return featureReducer(state, action);\n * }\n * ```\n * @template S, A\n * @param {?} initialState Provides a state value if the current state is `undefined`, as it is initially.\n * @param {...?} ons Associations between actions and state changes.\n * @return {?} A reducer function.\n *\n */\nfunction createReducer(initialState, ...ons) {\n    /** @type {?} */\n    const map = new Map();\n    for (let on of ons) {\n        for (let type of on.types) {\n            if (map.has(type)) {\n                /** @type {?} */\n                const existingReducer = (/** @type {?} */ (map.get(type)));\n                /** @type {?} */\n                const newReducer = (/**\n                 * @param {?} state\n                 * @param {?} action\n                 * @return {?}\n                 */\n                (state, action) => on.reducer(existingReducer(state, action), action));\n                map.set(type, newReducer);\n            }\n            else {\n                map.set(type, on.reducer);\n            }\n        }\n    }\n    return (/**\n     * @param {?=} state\n     * @param {?=} action\n     * @return {?}\n     */\n    function (state = initialState, action) {\n        /** @type {?} */\n        const reducer = map.get(action.type);\n        return reducer ? reducer(state, action) : state;\n    });\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: modules/store/src/index.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: modules/store/public_api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: modules/store/index.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ActionsSubject, FEATURE_REDUCERS, INIT, INITIAL_REDUCERS, INITIAL_STATE, META_REDUCERS, REDUCER_FACTORY, ReducerManager, ReducerManagerDispatcher, ReducerObservable, STORE_FEATURES, ScannedActionsSubject, State, StateObservable, Store, StoreFeatureModule, StoreModule, StoreRootModule, UPDATE, USER_PROVIDED_META_REDUCERS, USER_RUNTIME_CHECKS, combineReducers, compose, createAction, createFeatureSelector, createReducer, createReducerFactory, createSelector, createSelectorFactory, defaultMemoize, defaultStateFn, on, props, reduceState, resultMemoize, select, union, STORE_PROVIDERS as ngrx_modules_store_store_b, createSerializationCheckMetaReducer as ngrx_modules_store_store_ba, createImmutabilityCheckMetaReducer as ngrx_modules_store_store_bb, createInNgZoneCheckMetaReducer as ngrx_modules_store_store_bc, provideRuntimeChecks as ngrx_modules_store_store_bd, _runtimeChecksFactory as ngrx_modules_store_store_be, ACTIONS_SUBJECT_PROVIDERS as ngrx_modules_store_store_c, REDUCER_MANAGER_PROVIDERS as ngrx_modules_store_store_d, SCANNED_ACTIONS_SUBJECT_PROVIDERS as ngrx_modules_store_store_e, isEqualCheck as ngrx_modules_store_store_f, STATE_PROVIDERS as ngrx_modules_store_store_g, _ROOT_STORE_GUARD as ngrx_modules_store_store_h, _INITIAL_STATE as ngrx_modules_store_store_i, _REDUCER_FACTORY as ngrx_modules_store_store_j, _INITIAL_REDUCERS as ngrx_modules_store_store_k, _STORE_REDUCERS as ngrx_modules_store_store_l, _FEATURE_REDUCERS as ngrx_modules_store_store_m, _FEATURE_CONFIGS as ngrx_modules_store_store_n, _STORE_FEATURES as ngrx_modules_store_store_o, _FEATURE_REDUCERS_TOKEN as ngrx_modules_store_store_p, _RESOLVED_META_REDUCERS as ngrx_modules_store_store_q, _USER_RUNTIME_CHECKS as ngrx_modules_store_store_r, _ACTIVE_RUNTIME_CHECKS as ngrx_modules_store_store_s, _createStoreReducers as ngrx_modules_store_store_t, _createFeatureStore as ngrx_modules_store_store_u, _createFeatureReducers as ngrx_modules_store_store_v, _initialStateFactory as ngrx_modules_store_store_w, _concatMetaReducers as ngrx_modules_store_store_x, _provideForRootGuard as ngrx_modules_store_store_y, createActiveRuntimeChecks as ngrx_modules_store_store_z };\n"]}